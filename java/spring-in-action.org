* Foundational Spring
** Getting started
*** What is Spring ?
Any non-trival application is composed of many components, each responsible for its own piece of the overall application functionality, coordinating with the other application elements to get the job done. When the application is run, these components somehow need to be created and introduced to each other.

At its core, Spring offers a /container/, often referred to as the /Spring application context/, that creates and manages application components. These components, or /beans/, are wired together inside the Spring application context to make a complete application. 

The act of wiring beans together is based on a pattern known as /dependency injection/ (DI). Rather than have componenets create and maintain the lifecycle of other beans that they depend on, a dependency-injected application relies on a separate entity (container) to create and maintain all components and inject those into the beans that need them. This is done through constructor arguments or property accessor methods.

On top of its core container, Spring and set of related libraries offer a web framework, a variety of data persistence options, a security framework, integration with other systems, runtime monitoring, microservice support, a reactive programming model, and many other features necessary for modern application development.

Beans can be configured using XML-based configuration and Java-based configuration. E.g.

#+begin_src xml
<bean id="inventoryService"
      class="com.example.InventoryService" />
<bean id="productService"
      class="com.example.ProductService" />
  <constructor-arg ref="inventoryService" />
</bean>
#+end_src

#+begin_src java
@Configuration
public class ServiceConfiguration {
  @Bean
  public InventoryService inventoryService() {
    return new InventoryService();
  }
  @Bean
  public ProductService productService() {
    return new ProductService(inventoryService());
  }
}
#+end_src

Explicit configuration with either Java or XML is only necessary if Spring is unable to automatically cofigure the componenets. 

Automatic configuration in Spring is known as autowiring and componeent scanning. With compoenent scanning, Spring can automatically discover componenets from an application's classpath and create them as beans in Spring application context. With autowiring, Spring automatically injects the componenets with other beans that they depend on. Spring Boot enhances this with /autoconfiguration/ where Spring Boot can make reasonable guesses of what componenets need to be configured and wired together, based on entities in the classpath, environment variables and other factors.

*** Initializing a Spring application 
You can initialize a basic spring application with desired components using http://start.spring.io website. In Spring Tool Suite, you can use Spring Starter Project and create a spring project with spring starter website. For this example, we select the name as taco-cloud, package as tacos, group as sia, with description as "Taco Cloud Example". For components, select "Spring Boot DevTools, Spring Web, Thymeleaf, Lombok". Version of Spring Boot is 2.4.5. And web modelVersion is 4.0.0, java version 11. For this project I selected other packages also, e.g. Testing and Validation. The pom.xml looks like following code.
#+begin_src xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.4.5</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>sia</groupId>
	<artifactId>taco-cloud</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>taco-cloud</name>
	<description>Taco Cloud Example</description>
	<properties>
		<java.version>11</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.seleniumhq.selenium</groupId>
			<artifactId>selenium-java</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.seleniumhq.selenium</groupId>
			<artifactId>htmlunit-driver</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>

	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
#+end_src

We use jar packaging. Although by default it sets to jar packaging. Jar packages are good fit for all Java cloud platforms. If we want to deploy in traditional Java application server, when we need to choose WAR packaging and include a web initializer class. We use Thymeleaf for view template. We use Spring Boot starter maven packages, which reduces the dependencies we need to include in pom.xml, as these starter packages include needed packages themselves.


*** Bootstrapping the Application
Since we'll be running the application from an executable JAR, we need to have a main class that will be executed when that JAR file is run. We will also need at least a minimal amount of Spring configuration to bootstrap the application. That's what we find in TacoCloudApplication class as shown below.

#+begin_src java
package tacos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TacoCloudApplication {

	public static void main(String[] args) {
		SpringApplication.run(TacoCloudApplication.class, args);
	}

}
#+end_src

The @SpringBootApplication is composite application that combines @SpringBootConfiguraiton, @EnableAutoConfiguration and @ComponentScan. The first one specifies that this class is a configuration class, second annotation enables autoconfiguration, and @ComponenetScan enables other classes declared with @Component, @Controller, @Service and others and have Spring automatically discover and register them as components in the Spring application context. The SpringApplication.run() method performs actual bootstrapping of the application, creating the Spring application context. The two parameters passed to the run() method are a configuration class and the command-line arguments. Although it's not necessary that the configuration class passed to run() be the same as the bootstrap class, this is the most convenient and typical choice. We could define other configuration methods in this class, but we will create seperate configuration class, to keep this class clean.

*** Testing the application
Spring Initializer gives you a test class to get started. Code is shown below.
#+begin_src java
package tacos;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TacoCloudApplicationTests {

	@Test
	void contextLoads() {
	}

}
#+end_src

This class makes sure the Spring application context can be loaded successfully, otherwise the test fails. @SpringBootTest tells JUnit to bootstrap the test with Spring Boot Capabilities. For now, it's enough to think of this as the test class equivalent of calling SpringApplication.run() in a main() method.
*** Writing a Spring application
	For start we will create a controller that handles request for the homepage for Taco Cloud application and a view template that defines what the homepage looks like. We will also add unit test for the controller.
**** Handling web requests
Spring comes with a powerful web framework known as Spring MVC. At the center of the Spring MVC is the concept of a /controller/, a class that handles requests and reponds with information of some sort. In the case of a browser-facing application, a controller responds by optionally populating model date and passing the request on to a view to produce HTML that's returned to the browser. Below is code for HomeController.
#+begin_src java
  package tacos;

  import org.springframework.stereotype.Controller;
  import org.springframework.web.bind.annotation.GetMapping;

  @Controller
  public class HomeController {
	  @GetMapping("/")
	  public String home() {
		  return "home";
	  }
  }
#+end_src

As you  can see, this class is annotated with ~@Controller~. On its own, ~@controller~ doesn't do much. Its primary purpose is to identify this class as a componenet for component scanning. Because ~HomeController~ is  is annotated with @Controller, Spring's componenet scanning automatically discovers it and creates an instance of ~HomeController~ as a bean in the Spring application context. Other annotations including @Component, @Service and @Repository serve a purpose similar to @Controller. Any of these annotations would state the class for scanning, however @Controller is more descriptive of this component's role in the application. For the home() method, we use @GetMapping("/") annotation to indicate this method is called when an HTTP GET request is received for the root path "/". The method returns nothing more than returning a ~String~ value of ~home~.

This value is interpreted as the logical name of a view. How that view is implemented depends on a few factors, but because Thymeleaf is in our classpath, we can define that templated with Thymeleaf.

Thymleaf is a template engine. We could use JSP, FreeMarker etc. The template name is derived from the logical name by prefexiing it with /templates/ and postfixing it with .html. The resulting path for the template is /templates/home.html. Therefore, you'll need to place the template in your project at /src/main/resoures/templates/home.html. The home.html has following code.

#+begin_src html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
              xmlns:th="http://www.thymeleaf.org">
       <head>
       	<title>Taco Cloud</title>
       </head>   
       
       <body>
       	<h1>Welcome to ... </h1>
       	<h1>This is what</h1>
       	<img th:src="@{/images/TacoCloud.png}" />
       	<br/>
       	
       	<a th:href="@{/design}" id="another">Design Taco</a><br />
       </body> 
</html>
#+end_src

In the <img> tag we use TacoCloud.png. This file is located inside /src/main/resources/static/images/ folder. We can reference the image with a context-relative path with @{...} expression.

**** Testing the controller
Testing web applications can be tricky when making assertions against the content of an HTML page. Our test will perform an HTTP GET request for the root path / and expect a successful result where the view name is ~home~ and the resulting content contains the phrase "Welcome to ...".

#+begin_src java
package tacos;

import static org.hamcrest.CoreMatchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;

@WebMvcTest
public class HomeControllerTest {

	@Autowired
	private MockMvc mockMvc;
	
	@Test
	public void testHomePage() throws Exception {
		mockMvc.perform(get("/"))
			.andExpect(status().isOk())
			.andExpect(view().name("home"))
			.andExpect(content().string(containsString("Welcome to ...")));
	}
}
#+end_src

Instead of @SpringBooTest we use @WebMvcTest. This arranges for the test to run in the context of a Spring MVC application. More specifically, in htis case, it arranges for HomeController to be registered in Spring MVC so that you can throw requests against it. Although it could be made to start a server, mocking the mechanics of Spring MVC is sufficient for our purposes. The test class is injected with MockMvc object for the test to drive the mockup. Inside testHomePage() method, we perform HTTP GET request for the root path, and expect a HTTP 200 (OK) status. We also expect the view to have a logical name of home and the rendered view should contain the text "Welcome to ...".

Now you should be able to run the application and browse the homepage at [[http://localhost:8080][http://localhost:8080]]

[[./images/sia/01-taco-homepage.png]]

Since we have enabled devtools, we can make changes to code and it should build and run the changes right away. However, if you change some library file, make sure to restart. Dev tool loads two separate class loaders in the JVM. One class loader is loaded with java code, property file and pretty much anything that' in the src/main/ path of the project. These are items that are likely to change frequently. The other class loader is loaded with dependency libraries, which aren't likely to change as often. When a change is detected, DevTools reloads only the class loader containing your project code and restarts the Spring application context, but leaves the other class loader and the JVM intact. This reduces the time it takes to start the application. To automatically refresh browser when there is a change and disable template cache (for Thymeleaf) we can install LiveReload plugin in major browsers. To disable cache add following to application.properties.
#+begin_src bash
spring.thymeleaf.cache=false
#+end_src

*Note*: Make sure to enable caching in production by setting above to true.

Dev tools also allows us to access H2 Console from browser at [[http://localhost:8080/h2-console][http://localhost:8080/h2-console]].

*** Spring Components
- Core Spring Framework: Core container and dependency injection framework. It also includes Spring MVC, Sprin'ts web framework. Spring MVC can also be used to create REST APIs that produce non-HTML output. Core provides some elemental data persistence support, specifically template-based JDBC support. E.g. ~JdbcTemplate~. Spring also contains Spring WebFlux to support reactive-style programming.
- Spring Boot: Includes starter dependencies and autoconfiguration. Actuator provides runtime insight into the inner workings of an application like metrics, thread dump information, application health and environment properties. Additional testing support on top of testing found in core framework.
- Spring Data: Allows to define application's data repositories as simple Java interfaces, using a naming convention when defining methods to drive how data is stored and retrieved. Supports different databases, including relational (JPA), document (Mongo), graph (Neo4j) and others.
- Spring Security: Addresses a broad range of application security needs, including authentication, authorization and API security.
- Spring Integration and Spring Batch: Several patterns of application integration is provided. E.g. Real-time integration where data is processed as it's made available. In contrast, Spring Batch addresses batched integration where data is allowed to collect for a time until some trigger (perhaps a time trigger) signals that it's time for the batch of data to be processed.
- Spring Cloud: We'll no longer develop our applications as single deployment unit monoliths and will instead compose application from several individual deployment units known as /microservices/. Spring Cloud brings collection of projects for developing cloud-native applications with Spring. Can check /Spring Microservices in Action/.

** Developing web applications
We will expand on our Taco Cloud application. A customer will be able to make selection and pay and add address information. We will hardcode the data in java file, which later we will server from database in upcoming chapters.

*** Displaying information
 In a Spring web application, it's a controller's job to fetch and process data. And it's a view's job to render that data into HTML that will be displayed in the browser.

 For Taco Cloud application we will create a domain class that defines the properties of a taco ingredient. A Spring MVC controller class that fetches ingredient information and passes it along to the view and a view template that renders a list of ingredients in the user's browser.

 [[./images/sia/02-taco-controller.png]]

**** Establish the domain
 In Taco Cloud application, the domain includes objects such as taco designs, ingredients, customers and order placed by customers. Here we will focus on taco ingredients. We will have name of ingredient, with unique identifier id, with Type such as WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE.

 #+begin_src 
 package tacos;

 import lombok.Data;
 import lombok.RequiredArgsConstructor;

 @Data
 @RequiredArgsConstructor
 public class Ingredient {
	
	 private final String id;
	 private final String name;
	 private final Type type;
	
	 public static enum Type {
		 WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
	 }
 }
 #+end_src

 We also include lombok package, so that we don't have to write getter and setter or specify constructor with arguments. This makes the domain class much cleaner. The getter and setters are provided at runtime. To include lombok in STS, after installation include lombok jar in user libraries so that it is included globally. The @Data annotation at the class level tells Lombok to generate all of those missing methods as well as a constructor that accepts all /final/ properties as arguments. Lombok isn't spring library but can be easily added to Spring Boot starter.

**** Creating a controller class
Controller's primary job is to handle HTTP requests and either hand off to a view to render HTML (browser-displayed) or write data directly to the body of a response (RESTful). For Taco Cloud application, we want to handle HTTP GET requests where the request path is /design, build a list of ingredients, and hand the request and the ingredient data off to a view template to be rendered as HTML and sent to the requesting web browser. Follow code for DesignTacoController address above requirements.

#+begin_src java
package tacos.web;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import javax.validation.Valid;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import lombok.extern.slf4j.Slf4j;
import tacos.Ingredient;
import tacos.Ingredient.Type;
import tacos.Taco;

@Slf4j
@Controller
@RequestMapping("/design")
public class DesignTacoController {

	@GetMapping
	public String showDesignForm(Model model) {
		List<Ingredient> ingredients = Arrays.asList(
				new Ingredient("FLTO", "Flour Tortilla", Type.WRAP),
				new Ingredient("COTO", "Corn Tortilla", Type.WRAP),
				new Ingredient("GRBF", "Ground Beef", Type.PROTEIN),
			    new Ingredient("CARN", "Carnitas", Type.PROTEIN),
			    new Ingredient("TMTO", "Diced Tomatoes", Type.VEGGIES),
			    new Ingredient("LETC", "Lettuce", Type.VEGGIES),
			    new Ingredient("CHED", "Cheddar", Type.CHEESE),
			    new Ingredient("JACK", "Monterrey Jack", Type.CHEESE),
			    new Ingredient("SLSA", "Salsa", Type.SAUCE),
			    new Ingredient("SRCR", "Sour Cream", Type.SAUCE)
				);
		
		Type[] types = Ingredient.Type.values();
		for (Type type : types) {
			model.addAttribute(type.toString().toLowerCase(), filterByType(ingredients, type));
		}
		
		model.addAttribute("design", new Taco());
		
		return "design";
	}
	
	List<Ingredient> filterByType(List<Ingredient> ingredients, Type type) {
		return ingredients
				.stream()
				.filter(x -> x.getType().equals(type))
				.collect(Collectors.toList());
	}
	
	@PostMapping
	public String processDesign(@Valid @ModelAttribute("design") Taco design, Errors errors) {
		if (errors.hasErrors()) {
			return "design";
		}
		
		log.info("Processing design: " + design);
		
		return "redirect:/orders/current";
	}
}
#+end_src

The @Slf4j is a Lombok-provided annotation, that at runtime will automatically generate an SLF4J Logger for the current class with object name as /log/. We can use /log/ object to log any value in the class. The @Controller annotation declares current class as controller and marks it for componeent scanning. When Spring discovers the class it will create an instance of DesignTacoController as a bean in the Spring application context. We also annotate the class with @RequestMapping with path that begins with /design. In this case, it specifies that DesignTacocontroller will handle request whose path begins with /design.

We have two methods defined annotated with @GetMapping and @PostMapping. Since we don't add any additional URI, a GET request at /design will call showDesignForm method and a POST request at /design will call processDesign method. We could have also used @RequestMapping(method=RequestMethod.GET), however @GetMapping is much cleaner. Spring MVC supported request-mapping annotations are @RequestMapping (general purpose), @GetMapping (GET), @PostMapping (POST), @PutMapping (PUT), @DeleteMapping (DELETE) and @PatchMapping (HTTP PATCH). The showDesignForm method defines the ingredients list. In latr chapter we will get the list from database. We then filter each data with ingredient type like WRAP, PROTEIN etc. and add it to the Model object. /Model/ is an object that moves data between a controller and whatever view is chared with rendering that data. Ultimately, date that's placed in /Model/ attributes is copied into the servlet response attributes, where the view can find them. The ~showDesignForm()~ method concludes by returning "design", which is the logical name of the view that will be used to render the model to the browser.

**** Designing the view
Spring offers several great options for defining views, including JavaServer Pages (JSP), Thymeleaf, FreeMaker, Mustache, and Groovy-based templates. Here we'll use Thymeleaf. Since we included thymeleaf starter package in maven dependency, at runtime String Boot autoconfiguration will see that Thymeleaf is in the classpath and will automatically create the beans that support Thymeleaf views for Spring MVC.

View Libraries such as Thymeleaf are designed to be decoupled from any particular web framework. As such, they're unaware of Spring's model abstraction and are unable to work with the data that the controller places in /Model/. *But they can work with servlet request attributes*. Therefore, before Sprig handles the request over to a view, it copies the model data into request attributes that Thymeleaf and other view-templating options have ready access to.

Thymeleaf templates are just HTML with some additional element attributes that guide a template in rendering request data. For example, if there were a request attribute whose key is "message", and you wanted it to be rendered into an HTML <p> tag by Thymeleaf, you'd write the following in your Thymeleaf template:

~<p th:text="${message}">placeholder message</p>~
