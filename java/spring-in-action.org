* Foundational Spring
** Getting started
*** What is Spring ?
Any non-trival application is composed of many components, each responsible for its own piece of the overall application functionality, coordinating with the other application elements to get the job done. When the application is run, these components somehow need to be created and introduced to each other.

At its core, Spring offers a /container/, often referred to as the /Spring application context/, that creates and manages application components. These components, or /beans/, are wired together inside the Spring application context to make a complete application. 

The act of wiring beans together is based on a pattern known as /dependency injection/ (DI). Rather than have componenets create and maintain the lifecycle of other beans that they depend on, a dependency-injected application relies on a separate entity (container) to create and maintain all components and inject those into the beans that need them. This is done through constructor arguments or property accessor methods.

On top of its core container, Spring and set of related libraries offer a web framework, a variety of data persistence options, a security framework, integration with other systems, runtime monitoring, microservice support, a reactive programming model, and many other features necessary for modern application development.

Beans can be configured using XML-based configuration and Java-based configuration. E.g.

#+begin_src xml
<bean id="inventoryService"
      class="com.example.InventoryService" />
<bean id="productService"
      class="com.example.ProductService" />
  <constructor-arg ref="inventoryService" />
</bean>
#+end_src

#+begin_src java
@Configuration
public class ServiceConfiguration {
  @Bean
  public InventoryService inventoryService() {
    return new InventoryService();
  }
  @Bean
  public ProductService productService() {
    return new ProductService(inventoryService());
  }
}
#+end_src

Explicit configuration with either Java or XML is only necessary if Spring is unable to automatically cofigure the componenets. 

Automatic configuration in Spring is known as autowiring and componeent scanning. With compoenent scanning, Spring can automatically discover componenets from an application's classpath and create them as beans in Spring application context. With autowiring, Spring automatically injects the componenets with other beans that they depend on. Spring Boot enhances this with /autoconfiguration/ where Spring Boot can make reasonable guesses of what componenets need to be configured and wired together, based on entities in the classpath, environment variables and other factors.

*** Initializing a Spring application 
You can initialize a basic spring application with desired components using http://start.spring.io website. In Spring Tool Suite, you can use Spring Starter Project and create a spring project with spring starter website. For this example, we select the name as taco-cloud, package as tacos, group as sia, with description as "Taco Cloud Example". For components, select "Spring Boot DevTools, Spring Web, Thymeleaf, Lombok". Version of Spring Boot is 2.4.5. And web modelVersion is 4.0.0, java version 11. For this project I selected other packages also, e.g. Testing and Validation. The pom.xml looks like following code.
#+begin_src xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.4.5</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>sia</groupId>
	<artifactId>taco-cloud</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>taco-cloud</name>
	<description>Taco Cloud Example</description>
	<properties>
		<java.version>11</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.seleniumhq.selenium</groupId>
			<artifactId>selenium-java</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.seleniumhq.selenium</groupId>
			<artifactId>htmlunit-driver</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>

	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
#+end_src

We use jar packaging. Although by default it sets to jar packaging. Jar packages are good fit for all Java cloud platforms. If we want to deploy in traditional Java application server, when we need to choose WAR packaging and include a web initializer class. We use Thymeleaf for view template. We use Spring Boot starter maven packages, which reduces the dependencies we need to include in pom.xml, as these starter packages include needed packages themselves.


*** Bootstrapping the Application
Since we'll be running the application from an executable JAR, we need to have a main class that will be executed when that JAR file is run. We will also need at least a minimal amount of Spring configuration to bootstrap the application. That's what we find in TacoCloudApplication class as shown below.

#+begin_src java
package tacos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TacoCloudApplication {

	public static void main(String[] args) {
		SpringApplication.run(TacoCloudApplication.class, args);
	}

}
#+end_src

The @SpringBootApplication is composite application that combines @SpringBootConfiguraiton, @EnableAutoConfiguration and @ComponentScan. The first one specifies that this class is a configuration class, second annotation enables autoconfiguration, and @ComponenetScan enables other classes declared with @Component, @Controller, @Service and others and have Spring automatically discover and register them as components in the Spring application context. The SpringApplication.run() method performs actual bootstrapping of the application, creating the Spring application context. The two parameters passed to the run() method are a configuration class and the command-line arguments. Although it's not necessary that the configuration class passed to run() be the same as the bootstrap class, this is the most convenient and typical choice. We could define other configuration methods in this class, but we will create seperate configuration class, to keep this class clean.

*** Testing the application
Spring Initializer gives you a test class to get started. Code is shown below.
#+begin_src java
package tacos;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TacoCloudApplicationTests {

	@Test
	void contextLoads() {
	}

}
#+end_src

This class makes sure the Spring application context can be loaded successfully, otherwise the test fails. @SpringBootTest tells JUnit to bootstrap the test with Spring Boot Capabilities. For now, it's enough to think of this as the test class equivalent of calling SpringApplication.run() in a main() method.
*** Writing a Spring application
	For start we will create a controller that handles request for the homepage for Taco Cloud application and a view template that defines what the homepage looks like. We will also add unit test for the controller.
**** Handling web requests
Spring comes with a powerful web framework known as Spring MVC. At the center of the Spring MVC is the concept of a /controller/, a class that handles requests and reponds with information of some sort. In the case of a browser-facing application, a controller responds by optionally populating model date and passing the request on to a view to produce HTML that's returned to the browser. Below is code for HomeController.
#+begin_src java
  package tacos;

  import org.springframework.stereotype.Controller;
  import org.springframework.web.bind.annotation.GetMapping;

  @Controller
  public class HomeController {
	  @GetMapping("/")
	  public String home() {
		  return "home";
	  }
  }
#+end_src

As you  can see, this class is annotated with ~@Controller~. On its own, ~@controller~ doesn't do much. Its primary purpose is to identify this class as a componenet for component scanning. Because ~HomeController~ is  is annotated with @Controller, Spring's componenet scanning automatically discovers it and creates an instance of ~HomeController~ as a bean in the Spring application context. Other annotations including @Component, @Service and @Repository serve a purpose similar to @Controller. Any of these annotations would state the class for scanning, however @Controller is more descriptive of this component's role in the application. For the home() method, we use @GetMapping("/") annotation to indicate this method is called when an HTTP GET request is received for the root path "/". The method returns nothing more than returning a ~String~ value of ~home~.

This value is interpreted as the logical name of a view. How that view is implemented depends on a few factors, but because Thymeleaf is in our classpath, we can define that templated with Thymeleaf.

Thymleaf is a template engine. We could use JSP, FreeMarker etc. The template name is derived from the logical name by prefexiing it with /templates/ and postfixing it with .html. The resulting path for the template is /templates/home.html. Therefore, you'll need to place the template in your project at /src/main/resoures/templates/home.html. The home.html has following code.

#+begin_src html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
              xmlns:th="http://www.thymeleaf.org">
       <head>
       	<title>Taco Cloud</title>
       </head>   
       
       <body>
       	<h1>Welcome to ... </h1>
       	<h1>This is what</h1>
       	<img th:src="@{/images/TacoCloud.png}" />
       	<br/>
       	
       	<a th:href="@{/design}" id="another">Design Taco</a><br />
       </body> 
</html>
#+end_src

In the <img> tag we use TacoCloud.png. This file is located inside /src/main/resources/static/images/ folder. We can reference the image with a context-relative path with @{...} expression.

**** Testing the controller
Testing web applications can be tricky when making assertions against the content of an HTML page. Our test will perform an HTTP GET request for the root path / and expect a successful result where the view name is ~home~ and the resulting content contains the phrase "Welcome to ...".

#+begin_src java
package tacos;

import static org.hamcrest.CoreMatchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;

@WebMvcTest
public class HomeControllerTest {

	@Autowired
	private MockMvc mockMvc;
	
	@Test
	public void testHomePage() throws Exception {
		mockMvc.perform(get("/"))
			.andExpect(status().isOk())
			.andExpect(view().name("home"))
			.andExpect(content().string(containsString("Welcome to ...")));
	}
}
#+end_src

Instead of @SpringBooTest we use @WebMvcTest. This arranges for the test to run in the context of a Spring MVC application. More specifically, in htis case, it arranges for HomeController to be registered in Spring MVC so that you can throw requests against it. Although it could be made to start a server, mocking the mechanics of Spring MVC is sufficient for our purposes. The test class is injected with MockMvc object for the test to drive the mockup. Inside testHomePage() method, we perform HTTP GET request for the root path, and expect a HTTP 200 (OK) status. We also expect the view to have a logical name of home and the rendered view should contain the text "Welcome to ...".

Now you should be able to run the application and browse the homepage at [[http://localhost:8080][http://localhost:8080]]

[[./images/sia/01-taco-homepage.png]]

Since we have enabled devtools, we can make changes to code and it should build and run the changes right away. However, if you change some library file, make sure to restart. Dev tool loads two separate class loaders in the JVM. One class loader is loaded with java code, property file and pretty much anything that' in the src/main/ path of the project. These are items that are likely to change frequently. The other class loader is loaded with dependency libraries, which aren't likely to change as often. When a change is detected, DevTools reloads only the class loader containing your project code and restarts the Spring application context, but leaves the other class loader and the JVM intact. This reduces the time it takes to start the application. To automatically refresh browser when there is a change and disable template cache (for Thymeleaf) we can install LiveReload plugin in major browsers. To disable cache add following to application.properties.
#+begin_src bash
spring.thymeleaf.cache=false
#+end_src

*Note*: Make sure to enable caching in production by setting above to true.

Dev tools also allows us to access H2 Console from browser at [[http://localhost:8080/h2-console][http://localhost:8080/h2-console]].

*** Spring Components
- Core Spring Framework: Core container and dependency injection framework. It also includes Spring MVC, Sprin'ts web framework. Spring MVC can also be used to create REST APIs that produce non-HTML output. Core provides some elemental data persistence support, specifically template-based JDBC support. E.g. ~JdbcTemplate~. Spring also contains Spring WebFlux to support reactive-style programming.
- Spring Boot: Includes starter dependencies and autoconfiguration. Actuator provides runtime insight into the inner workings of an application like metrics, thread dump information, application health and environment properties. Additional testing support on top of testing found in core framework.
- Spring Data: Allows to define application's data repositories as simple Java interfaces, using a naming convention when defining methods to drive how data is stored and retrieved. Supports different databases, including relational (JPA), document (Mongo), graph (Neo4j) and others.
- Spring Security: Addresses a broad range of application security needs, including authentication, authorization and API security.
- Spring Integration and Spring Batch: Several patterns of application integration is provided. E.g. Real-time integration where data is processed as it's made available. In contrast, Spring Batch addresses batched integration where data is allowed to collect for a time until some trigger (perhaps a time trigger) signals that it's time for the batch of data to be processed.
- Spring Cloud: We'll no longer develop our applications as single deployment unit monoliths and will instead compose application from several individual deployment units known as /microservices/. Spring Cloud brings collection of projects for developing cloud-native applications with Spring. Can check /Spring Microservices in Action/.

** Developing web applications
We will expand on our Taco Cloud application. A customer will be able to make selection and pay and add address information. We will hardcode the data in java file, which later we will server from database in upcoming chapters.

*** Displaying information
 In a Spring web application, it's a controller's job to fetch and process data. And it's a view's job to render that data into HTML that will be displayed in the browser.

 For Taco Cloud application we will create a domain class that defines the properties of a taco ingredient. A Spring MVC controller class that fetches ingredient information and passes it along to the view and a view template that renders a list of ingredients in the user's browser.

 [[./images/sia/02-taco-controller.png]]

**** Establish the domain
 In Taco Cloud application, the domain includes objects such as taco designs, ingredients, customers and order placed by customers. Here we will focus on taco ingredients. We will have name of ingredient, with unique identifier id, with Type such as WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE.

 #+begin_src 
 package tacos;

 import lombok.Data;
 import lombok.RequiredArgsConstructor;

 @Data
 @RequiredArgsConstructor
 public class Ingredient {
	
	 private final String id;
	 private final String name;
	 private final Type type;
	
	 public static enum Type {
		 WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
	 }
 }
 #+end_src

 We also include lombok package, so that we don't have to write getter and setter or specify constructor with arguments. This makes the domain class much cleaner. The getter and setters are provided at runtime. To include lombok in STS, after installation include lombok jar in user libraries so that it is included globally. The @Data annotation at the class level tells Lombok to generate all of those missing methods as well as a constructor that accepts all /final/ properties as arguments. Lombok isn't spring library but can be easily added to Spring Boot starter.

**** Creating a controller class
Controller's primary job is to handle HTTP requests and either hand off to a view to render HTML (browser-displayed) or write data directly to the body of a response (RESTful). For Taco Cloud application, we want to handle HTTP GET requests where the request path is /design, build a list of ingredients, and hand the request and the ingredient data off to a view template to be rendered as HTML and sent to the requesting web browser. Follow code for DesignTacoController address above requirements.

#+begin_src java
package tacos.web;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import javax.validation.Valid;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import lombok.extern.slf4j.Slf4j;
import tacos.Ingredient;
import tacos.Ingredient.Type;
import tacos.Taco;

@Slf4j
@Controller
@RequestMapping("/design")
public class DesignTacoController {

	@GetMapping
	public String showDesignForm(Model model) {
		List<Ingredient> ingredients = Arrays.asList(
				new Ingredient("FLTO", "Flour Tortilla", Type.WRAP),
				new Ingredient("COTO", "Corn Tortilla", Type.WRAP),
				new Ingredient("GRBF", "Ground Beef", Type.PROTEIN),
			    new Ingredient("CARN", "Carnitas", Type.PROTEIN),
			    new Ingredient("TMTO", "Diced Tomatoes", Type.VEGGIES),
			    new Ingredient("LETC", "Lettuce", Type.VEGGIES),
			    new Ingredient("CHED", "Cheddar", Type.CHEESE),
			    new Ingredient("JACK", "Monterrey Jack", Type.CHEESE),
			    new Ingredient("SLSA", "Salsa", Type.SAUCE),
			    new Ingredient("SRCR", "Sour Cream", Type.SAUCE)
				);
		
		Type[] types = Ingredient.Type.values();
		for (Type type : types) {
			model.addAttribute(type.toString().toLowerCase(), filterByType(ingredients, type));
		}
		
		model.addAttribute("design", new Taco());
		
		return "design";
	}
	
	List<Ingredient> filterByType(List<Ingredient> ingredients, Type type) {
		return ingredients
				.stream()
				.filter(x -> x.getType().equals(type))
				.collect(Collectors.toList());
	}
	
	@PostMapping
	public String processDesign(@Valid @ModelAttribute("design") Taco design, Errors errors) {
		if (errors.hasErrors()) {
			return "design";
		}
		
		log.info("Processing design: " + design);
		
		return "redirect:/orders/current";
	}
}
#+end_src

The @Slf4j is a Lombok-provided annotation, that at runtime will automatically generate an SLF4J Logger for the current class with object name as /log/. We can use /log/ object to log any value in the class. The @Controller annotation declares current class as controller and marks it for componeent scanning. When Spring discovers the class it will create an instance of DesignTacoController as a bean in the Spring application context. We also annotate the class with @RequestMapping with path that begins with /design. In this case, it specifies that DesignTacocontroller will handle request whose path begins with /design.

We have two methods defined annotated with @GetMapping and @PostMapping. Since we don't add any additional URI, a GET request at /design will call showDesignForm method and a POST request at /design will call processDesign method. We could have also used @RequestMapping(method=RequestMethod.GET), however @GetMapping is much cleaner. Spring MVC supported request-mapping annotations are @RequestMapping (general purpose), @GetMapping (GET), @PostMapping (POST), @PutMapping (PUT), @DeleteMapping (DELETE) and @PatchMapping (HTTP PATCH). The showDesignForm method defines the ingredients list. In latr chapter we will get the list from database. We then filter each data with ingredient type like WRAP, PROTEIN etc. and add it to the Model object. /Model/ is an object that moves data between a controller and whatever view is chared with rendering that data. Ultimately, date that's placed in /Model/ attributes is copied into the servlet response attributes, where the view can find them. The ~showDesignForm()~ method concludes by returning "design", which is the logical name of the view that will be used to render the model to the browser.

**** Designing the view
Spring offers several great options for defining views, including JavaServer Pages (JSP), Thymeleaf, FreeMaker, Mustache, and Groovy-based templates. Here we'll use Thymeleaf. Since we included thymeleaf starter package in maven dependency, at runtime String Boot autoconfiguration will see that Thymeleaf is in the classpath and will automatically create the beans that support Thymeleaf views for Spring MVC.

View Libraries such as Thymeleaf are designed to be decoupled from any particular web framework. As such, they're unaware of Spring's model abstraction and are unable to work with the data that the controller places in /Model/. *But they can work with servlet request attributes*. Therefore, before Sprig handles the request over to a view, it copies the model data into request attributes that Thymeleaf and other view-templating options have ready access to.

Thymeleaf templates are just HTML with some additional element attributes that guide a template in rendering request data. For example, if there were a request attribute whose key is "message", and you wanted it to be rendered into an HTML <p> tag by Thymeleaf, you'd write the following in your Thymeleaf template:

~<p th:text="${message}">placeholder message</p>~

When the template is rendered into HTML, the body of the <p> element will be replaced with the value of the servlet request attribute whose key is "message". The th:text attribute is a Thymeleaf-namespaced attribute that perform the replacement. The ${} operator tells it to use the value of a request attribute ("message", in this case).

Thymeleaf also offers another attribute, th:each, that iterates over a collection of elements, rendering the HTML once for each item in the collection. This will come in handy as we design our view to list taco ingredients from the model. For example, to render just the list of "wrap" ingredients, we can use the following snippet of HTML:

#+begin_src html
<h3>Designate your wrap:</h3>
<div th:each="ingredient : ${wrap}">
  <input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
  <span th:text="${ingredient.name}">INGREDIENT</span><br/>
</div>
#+end_src

Here th:each will render new div for each wrap element from the list with the enclosed content. The name of each checkbox will be ingredients. This variable will capture each of the chosen ingredients. However each object of wrap is bound to thymeleaf local variable "ingredient". We can access each attribute using this variable.

A single div will look like following
#+begin_src html
div>
  <input name="ingredients" type="checkbox" value="FLTO" />
  <span>Flour Tortilla</span><br/>
</div>
#+end_src

Below we have complete code for design.html
#+begin_src html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">

<head>
	<title>Taco Cloud</title>
	<link rel="stylesheet" th:href="@{/styles.css}" />
</head>

<body>
	<h1>Design your taco!</h1>
	<img th:src="@{/images/TacoCloud.png}" />

	<form method="POST" th:object="${design}">

		<span class="validationError" th:if="${#fields.hasErrors('ingredients')}"
          th:errors="*{ingredients}">Ingredient Error</span>
	
		<div class="grid">
		
			<div class="ingredient-group" id="wraps">
				<h3>Designate your wrap:</h3>
				<div th:each="ingredient : ${wrap}">
					<input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
					<span th:text="${ingredient.name}">INGREDIENT</span><br/>
					
				</div>
			</div>
		
			<div class="ingredient-group" id="proteins">
				<h3>Pick your protein:</h3>
				<div th:each="ingredient : ${protein}">
					<input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
					<span th:text="${ingredient.name}">INGREDIENT</span><br/>
				</div>
			</div>
			
			<div class="ingredient-group" id="cheeses">
				<h3>Choose your cheese:</h3>
				<div th:each="ingredient : ${cheese}">
					<input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
					<span th:text="${ingredient.name}">INGREDIENT</span><br/>
				</div>
			</div>
			
			
			<div class="ingredient-group" id="veggies">
				<h3>Determine your veggies:</h3>
				<div th:each="ingredient : ${veggies}">
					<input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
					<span th:text="${ingredient.name}">INGREDIENT</span><br/>
				</div>
			</div>
			
			<div class="ingredient-group" id="sauces">
				<h3>Select your sauce:</h3>
				<div th:each="ingredient : ${sauce}">
					<input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
					<span th:text="${ingredient.name}">INGREDIENT</span><br/>
				</div>
			</div>
			
			
			<h3>Name your taco creation:</h3>
			<input type="text" th:field="*{name}" />
			 <span th:text="${#fields.hasErrors('name')}">XXX</span>
      		 <span class="validationError"
            	th:if="${#fields.hasErrors('name')}"
            	th:errors="*{name}">Name Error</span>
			<br/>
			
			<button>Sumbit your taco</button>
			
		</div>
	</form>
	
</body>
</html>
#+end_src

We repeat <div> snippet for each type of ingredients. We also include a Submit button for the form. All the form object is bound to "design" object which is a type of model class called Taco. With two attributes: "name" (String) and "ingredients" (list of string). In DesignTacoController, we have defined the "design" key and added to model object. We also link to "TacoCloud.png" using relative path in /static directory. In the processDesign method in the controller we accept model attribute of "design" of type Taco and redirect the request to /orders/current URI. The Taco class looks like following.

#+begin_src java
package tacos;

import java.util.List;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import lombok.Data;

@Data
public class Taco {
	
	@NotNull
	@Size(min = 5, message = "Name must be at least 5 characters long")
	private String name;
	
	@Size(min = 1, message = "You must choose at least 1 ingredient")
	private List<String> ingredients;
}
#+end_src

Similarly the redirected /orders/current controller will look like following.

#+begin_src java
package tacos.web;

import javax.validation.Valid;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import lombok.extern.slf4j.Slf4j;
import tacos.Order;

@Slf4j
@Controller
@RequestMapping("/orders")
public class OrderController {

	@GetMapping("/current")
	public String orderForm(Model model) {
		model.addAttribute("order", new Order());
		return "orderForm";
	}
	
	@PostMapping
	public String processOrder(@Valid Order order, Errors errors) {
		
		if (errors.hasErrors()) {
			return "orderForm";
		}
		
		log.info("Order submitted: " + order);
		return "redirect:/";
	}
}
#+end_src

The GET method for /orders/current will return "orderForm" and post will process the data (nothing for now) and redirect to the home page. The orderForm view will look like following.

#+begin_src html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">

<head>
	<title>Taco Cloud</title>
	<link rel="stylesheet" th:href="@{/styles.css}" />
</head>

<body>
	<form method="POST" th:action="@{/orders}" th:object="${order}">
		<h1>Order your taco creations!</h1>

		<img th:src="@{/images/TacoCloud.png}" />
		<a th:href="@{/design}" id="another">Design another taco</a><br />

		<div th:if="${#fields.hasErrors()}">
				<span class="validationError">
					Please correct the problems below and resubmit.
				</span>
			</div>
			
			
			<h3>Deliver my taco masterpieces to...</h3>
			<label for="name">Name: </label>
			<input type="text" th:field="*{name}" />
			<span class="validationError"
				th:if="${#fields.hasErrors('name')}"
				th:errors="*{name}">Name Error</span>
			<br />
			<label for="street">Street address: </label>
			<input type="text" th:field="*{street}" />
			<span class="validationError"
            th:if="${#fields.hasErrors('street')}"
            th:errors="*{street}">Street Error</span>
			<br />
			<label for="city">City: </label>
			<input type="text" th:field="*{city}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('city')}"
            th:errors="*{city}">City Error</span>
			<br />
			<label for="state">State: </label>
			<input type="text" th:field="*{state}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('state')}"
            th:errors="*{state}">State Error</span>
			<br />
			<label for="zip">Zip code: </label>
			<input type="text" th:field="*{zip}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('zip')}"
			<br />
			
			<h3>Here's how I'll pay...</h3>
			<label for="ccNumber">Credit Card #: </label>
			<input type="text" th:field="*{ccNumber}" />
			<span class="validationError"
				th:if="${#fields.hasErrors('ccNumber')}"
				th:errors="*{ccNumber}">CC Num Error</span>
				 <span class="validationError"
            th:if="${#fields.hasErrors('ccNumber')}"
            th:errors="*{ccNumber}">CC Num Error</span>
			<br />
			<label for="ccExpiration">Expiration: </label>
			<input type="text" th:field="*{ccExpiration}" />
			 <span class="validationError"
            	th:if="${#fields.hasErrors('ccExpiration')}"
            	th:errors="*{ccExpiration}">CC Num Error</span>
			<br />
			<label for="ccCVV">CVV: </label>
			<input type="text" th:field="*{ccCVV}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('ccCVV')}"
            th:errors="*{ccCVV}">CC Num Error</span>
			<br />
			<input type="submit" value="Submit order" />
			
		</form>
	</body>

</html>
#+end_src

The action of POST is /orders. As you can see in OrderController there is no extra mapping for POSTMapping. Thus processOrder method will handle the post method. The form field maps to Order class just like Taco. Below is the code for Order class.

#+begin_src java
package tacos;

import javax.validation.constraints.Digits;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;

import org.hibernate.validator.constraints.CreditCardNumber;

import lombok.Data;

@Data
public class Order {
	
	@NotBlank(message = "Name is required")
	private String name;
	
	@NotBlank(message = "Street is required")
	private String street;
	
	@NotBlank(message = "City is required")
	private String city;
	
	@NotBlank(message = "State is required")
	private String state;
	
	@NotBlank(message = "Zip code is required")
	private String zip;
	
	@CreditCardNumber(message = "Not a valid credit card number")
	private String ccNumber;
	
	@Pattern(regexp="^(0[1-9]|1[0-2])([\\/])([1-9][0-9])$",
	           message="Must be formatted MM/YY")
	private String ccExpiration;
	
	@Digits(integer=3, fraction = 0, message = "Invalid CVV")
	private String ccCVV;
}
#+end_src

*** Validating form input
If you see Taco and Order class, we have added different validation rules for each attributes. E.g. We specified that name should not be null and should contain at least 5 character. We also specify the message that needs to be displayed when the rule is not met. In case or Order class we use @CreditCardNumber annotation from hibernate (that checks with Luhn_algorithm) for credit card number. For ccExpiration date, we define our own regex rule. In the processDesign method we return back the view "design" if the form has errors. We do same for processOrder method. We use @Valid annotation to instruct the method to validate Order. To display validation errors, we can use a class "validationError" that displays differently using css style. The syntax is as follows for credit card number.

#+begin_src html
<label for="ccNumber">Credit Card #: </label>
        <input type="text" th:field="*{ccNumber}"/>
        <span class="validationError"
              th:if="${#fields.hasErrors('ccNumber')}"
              th:errors="*{ccNumber}">CC Num Error</span>
#+end_src

The code for orderForm.html looks like following.

#+begin_src html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">

<head>
	<title>Taco Cloud</title>
	<link rel="stylesheet" th:href="@{/styles.css}" />
</head>

<body>
	<form method="POST" th:action="@{/orders}" th:object="${order}">
		<h1>Order your taco creations!</h1>

		<img th:src="@{/images/TacoCloud.png}" />
		<a th:href="@{/design}" id="another">Design another taco</a><br />

		<div th:if="${#fields.hasErrors()}">
				<span class="validationError">
					Please correct the problems below and resubmit.
				</span>
			</div>
			
			
			<h3>Deliver my taco masterpieces to...</h3>
			<label for="name">Name: </label>
			<input type="text" th:field="*{name}" />
			<span class="validationError"
				th:if="${#fields.hasErrors('name')}"
				th:errors="*{name}">Name Error</span>
			<br />
			<label for="street">Street address: </label>
			<input type="text" th:field="*{street}" />
			<span class="validationError"
            th:if="${#fields.hasErrors('street')}"
            th:errors="*{street}">Street Error</span>
			<br />
			<label for="city">City: </label>
			<input type="text" th:field="*{city}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('city')}"
            th:errors="*{city}">City Error</span>
			<br />
			<label for="state">State: </label>
			<input type="text" th:field="*{state}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('state')}"
            th:errors="*{state}">State Error</span>
			<br />
			<label for="zip">Zip code: </label>
			<input type="text" th:field="*{zip}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('zip')}"
			<br />
			
			<h3>Here's how I'll pay...</h3>
			<label for="ccNumber">Credit Card #: </label>
			<input type="text" th:field="*{ccNumber}" />
			<span class="validationError"
				th:if="${#fields.hasErrors('ccNumber')}"
				th:errors="*{ccNumber}">CC Num Error</span>
				 <span class="validationError"
            th:if="${#fields.hasErrors('ccNumber')}"
            th:errors="*{ccNumber}">CC Num Error</span>
			<br />
			<label for="ccExpiration">Expiration: </label>
			<input type="text" th:field="*{ccExpiration}" />
			 <span class="validationError"
            	th:if="${#fields.hasErrors('ccExpiration')}"
            	th:errors="*{ccExpiration}">CC Num Error</span>
			<br />
			<label for="ccCVV">CVV: </label>
			<input type="text" th:field="*{ccCVV}" />
			 <span class="validationError"
            th:if="${#fields.hasErrors('ccCVV')}"
            th:errors="*{ccCVV}">CC Num Error</span>
			<br />
			<input type="submit" value="Submit order" />
			
		</form>
	</body>
</html>
#+end_src

The css file that helps in displaying error looks like following

#+begin_src css
div.ingredient-group:nth-child(odd) {
	float: left;
	padding-right: 20px;
}

div.ingredient-group:nth-child(even) {
    float: left;
	padding-right: 0;
}

div.ingredient-group {
	width: 50%;
}

.grid:after {
  content: "";
  display: table;
  clear: both;
}

*, *:after, *:before {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

span.validationError {
	color: red;
}
#+end_src

Finally, we can replace HomeController with WebConfi class that works as a view controller. Below is the code

#+begin_src java
package tacos.web;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

	// If you just want to forward some request without process
	// Override addViewControllers method of WebMvcConfigurer interface
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController("/").setViewName("home");
	}
}
#+end_src

The addViewControllers() method is given a ViewControllerRegistry that we can use to register one or more view controllers. Here we pass "/" which is the path to handle GET request for "home" view. With above class you can remove HomeController and HomeControllerTest classes.

If we run the application, the [[http://localhost:8080/design]] looks like following.

[[./images/sia/03-taco-design.png]]

Validation for Taco Design looks like following

[[./images/sia/04-taco-design-validation.png]]


And finally once you correct above form, you get to orderForm, where you can enter address and credit card information. Validation error in orderForm.html looks like following.

[[./images/sia/05-taco-order-validation.png]]

And correct data for taco order looks like following

[[./images/sia/06-taco-order-correct-data.png]]
